{"version":3,"file":"SpanParser.js","sourceRoot":"","sources":["../../../AutoCollection/diagnostic-channel/SpanParser.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA,4DAA4D;AAC5D,oFAAoF;AACpF,0CAA8E;AAG9E,wDAA0D;AAE1D,SAAS,oBAAoB,CAAC,UAA0B;IACpD,IAAM,aAAa,gBAAQ,UAAU,CAAE,CAAC;IACxC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,aAAa,CAAC,CAAC,OAAO,CAAC,UAAA,GAAG;QAC5C,OAAO,aAAa,CAAC,GAAG,CAAC,CAAC;IAC9B,CAAC,CAAC,CAAC;IACH,OAAO,aAAa,CAAA;AACxB,CAAC;AAED,SAAgB,uBAAuB,CAAC,IAAU;IAC9C,IAAM,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CAAC,CAAO,IAAK,CAAC,OAAO,EAAE,CAAC,CAAC,0CAA0C;IAC7H,IAAM,EAAE,GAAG,MAAI,WAAW,CAAC,OAAO,SAAI,WAAW,CAAC,MAAM,MAAG,CAAC;IAC5D,IAAM,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC;IACrF,IAAI,WAAW,GAAG,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;IAEpG,IAAM,MAAM,GAAY,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,aAAa,CAAC,cAAc,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC;IAC5I,IAAM,MAAM,GAAY,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,aAAa,CAAC,cAAc,CAAC,CAAC,CAAC;IACpF,IAAI,MAAM,EAAE;QACR,4BAA4B;QAC5B,IAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,aAAa,CAAC,UAAU,CAAC,IAAI,KAAK,CAAC;QAC5E,IAAM,GAAG,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,aAAa,CAAC,OAAO,CAAW,CAAC,CAAC;QAChF,IAAM,QAAQ,GAAG,GAAG,CAAC,QAAQ,IAAI,GAAG,CAAC;QAErC,oCAAoC;QACpC,IAAM,MAAI,GAAM,MAAM,SAAI,QAAU,CAAC;QACrC,IAAM,kBAAkB,GAAG,SAAS,CAAC,kBAAkB,CAAC,IAAI,CAAC;QAC7D,IAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC;QAC3F,IAAM,IAAI,GAAG,GAAG,CAAC,QAAQ,EAAE,CAAC;QAC5B,IAAM,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,aAAa,CAAC,cAAc,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,CAAC;QACpG,IAAM,OAAO,GAAG,UAAU,GAAG,GAAG,CAAC,CAAC,YAAY;QAC9C,OAAO;YACH,EAAE,IAAA,EAAE,IAAI,QAAA,EAAE,kBAAkB,oBAAA;YAC5B,MAAM,QAAA,EAAE,IAAI,MAAA;YACZ,OAAO,SAAA,EAAE,QAAQ,UAAA;YACjB,GAAG,EAAE,IAAI;YACT,UAAU,EAAE,MAAM,CAAC,UAAU,CAAC;YAC9B,UAAU,EAAE,oBAAoB,CAAC,IAAI,CAAC,UAAU,CAAC;SACpD,CAAC;KACL;SAAM,IAAI,MAAM,EAAE;QACf,IAAM,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,aAAa,CAAC,UAAU,CAAC,IAAI,KAAK,CAAC;QAC5E,IAAM,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,aAAa,CAAC,WAAW,CAAC,CAAC;QACrE,IAAM,MAAI,GAAG,OAAO,CAAC,CAAC,CAAI,MAAM,SAAI,OAAS,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;QAC1D,OAAO;YACH,EAAE,IAAA,EAAE,QAAQ,UAAA,EAAE,IAAI,QAAA;YAClB,MAAM,EAAE,MAAM,CAAC,QAAQ,EAAE;YACzB,IAAI,EAAE,OAAO,CAAC,QAAQ,EAAE,IAAI,MAAI;YAChC,GAAG,EAAE,OAAO,CAAC,QAAQ,EAAE,IAAI,MAAI;YAC/B,kBAAkB,EAAE,SAAS,CAAC,kBAAkB,CAAC,IAAI;YACrD,UAAU,EAAE,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,aAAa,CAAC,cAAc,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,CAAC;YACpG,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,IAAI,KAAK,oBAAc,CAAC,EAAE;YAC/C,UAAU,EAAE,oBAAoB,CAAC,IAAI,CAAC,UAAU,CAAC;SACpD,CAAA;KACJ;SAAM;QACH,IAAM,MAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACvB,IAAM,KAAK,GAAG,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,UAAA,IAAI;YAC3C,OAAO;gBACH,YAAY,EAAE,IAAI,CAAC,OAAO,CAAC,OAAO;gBAClC,EAAE,EAAE,IAAI,CAAC,OAAO,CAAC,MAAM;aAC1B,CAAC;QACN,CAAC,CAAC,CAAC;QACH,OAAO;YACH,EAAE,IAAA,EAAE,QAAQ,UAAA,EAAE,IAAI,QAAA;YAClB,MAAM,EAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,aAAa,CAAC,OAAO,CAAY,IAAI,SAAS;YACjF,IAAI,EAAE,WAAW,IAAI,MAAI;YACzB,GAAG,EAAE,WAAW,IAAI,MAAI;YACxB,kBAAkB,EAAE,IAAI,CAAC,IAAI,KAAK,cAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC,kBAAkB,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI;YACrG,UAAU,EAAE,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,IAAI,CAAC,CAAC;YACzC,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,IAAI,KAAK,oBAAc,CAAC,KAAK;YAClD,UAAU,wBACH,oBAAoB,CAAC,IAAI,CAAC,UAAU,CAAC,KACxC,WAAW,EAAE,KAAK,IAAI,SAAS,GAClC;SACJ,CAAC;KACL;AACL,CAAC;AAjED,0DAiEC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE file in the project root for details.\r\nimport { SpanAttributes, SpanKind, SpanStatusCode } from \"@opentelemetry/api\";\r\nimport { Span } from \"@opentelemetry/tracing\";\r\nimport * as Contracts from \"../../Declarations/Contracts\";\r\nimport * as Constants from \"../../Declarations/Constants\";\r\n\r\nfunction filterSpanAttributes(attributes: SpanAttributes) {\r\n    const newAttributes = { ...attributes };\r\n    Object.keys(Constants.SpanAttribute).forEach(key => {\r\n        delete newAttributes[key];\r\n    });\r\n    return newAttributes\r\n}\r\n\r\nexport function spanToTelemetryContract(span: Span): (Contracts.DependencyTelemetry & Contracts.RequestTelemetry) & Contracts.Identified {\r\n    const spanContext = span.spanContext ? span.spanContext() : (<any>span).context(); // context is available in OT API <v0.19.0\r\n    const id = `|${spanContext.traceId}.${spanContext.spanId}.`;\r\n    const duration = Math.round(span[\"_duration\"][0] * 1e3 + span[\"_duration\"][1] / 1e6);\r\n    let peerAddress = span.attributes[\"peer.address\"] ? span.attributes[\"peer.address\"].toString() : \"\";\r\n\r\n    const isHttp: boolean = (!!span.attributes[Constants.SpanAttribute.HttpStatusCode]) || (!!span.attributes[Constants.SpanAttribute.HttpUrl]);\r\n    const isGrpc: boolean = (!!span.attributes[Constants.SpanAttribute.GrpcStatusCode]);\r\n    if (isHttp) {\r\n        // Read http span attributes\r\n        const method = span.attributes[Constants.SpanAttribute.HttpMethod] || \"GET\";\r\n        const url = new URL(span.attributes[Constants.SpanAttribute.HttpUrl] as string);\r\n        const pathname = url.pathname || \"/\";\r\n\r\n        // Translate to AI Dependency format\r\n        const name = `${method} ${pathname}`;\r\n        const dependencyTypeName = Constants.DependencyTypeName.Http;\r\n        const target = span.attributes[Constants.SpanAttribute.HttpUrl] ? url.hostname : undefined;\r\n        const data = url.toString();\r\n        const resultCode = span.attributes[Constants.SpanAttribute.HttpStatusCode] || span.status.code || 0;\r\n        const success = resultCode < 400; // Status.OK\r\n        return {\r\n            id, name, dependencyTypeName,\r\n            target, data,\r\n            success, duration,\r\n            url: data,\r\n            resultCode: String(resultCode),\r\n            properties: filterSpanAttributes(span.attributes)\r\n        };\r\n    } else if (isGrpc) {\r\n        const method = span.attributes[Constants.SpanAttribute.GrpcMethod] || \"rpc\";\r\n        const service = span.attributes[Constants.SpanAttribute.GrpcService];\r\n        const name = service ? `${method} ${service}` : span.name;\r\n        return {\r\n            id, duration, name,\r\n            target: method.toString(),\r\n            data: service.toString() || name,\r\n            url: service.toString() || name,\r\n            dependencyTypeName: Constants.DependencyTypeName.Grpc,\r\n            resultCode: String(span.attributes[Constants.SpanAttribute.GrpcStatusCode] || span.status.code || 0),\r\n            success: span.status.code === SpanStatusCode.OK,\r\n            properties: filterSpanAttributes(span.attributes),\r\n        }\r\n    } else {\r\n        const name = span.name;\r\n        const links = span.links && span.links.map(link => {\r\n            return {\r\n                operation_Id: link.context.traceId,\r\n                id: link.context.spanId\r\n            };\r\n        });\r\n        return {\r\n            id, duration, name,\r\n            target: (span.attributes[Constants.SpanAttribute.HttpUrl] as string) || undefined,\r\n            data: peerAddress || name,\r\n            url: peerAddress || name,\r\n            dependencyTypeName: span.kind === SpanKind.INTERNAL ? Constants.DependencyTypeName.InProc : span.name,\r\n            resultCode: String(span.status.code || 0),\r\n            success: span.status.code !== SpanStatusCode.ERROR,\r\n            properties: {\r\n                ...filterSpanAttributes(span.attributes),\r\n                \"_MS.links\": links || undefined\r\n            },\r\n        };\r\n    }\r\n}\r\n"]}